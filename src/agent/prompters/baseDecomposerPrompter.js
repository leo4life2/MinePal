import { BasePrompter } from './basePrompter.js';
import { createNLNode, createActionNode } from '../taskTree.js';

const COMMON_INSTRUCTIONS = `
Formulate these subtasks as a *disjoint set* S = { s₁, s₂, …, sₙ },
where each sᵢ is a complete, independent requirement that can be executed
in any order relative to the others. No subtask may depend on the outcome
of another, and no conditional phrasing (if, then, else, after, when, otherwise) is allowed.

A subtask may ONLY be included if it is logically required in all possible world states.
Subtasks must be grounded strictly in the provided HUD snapshot.
If the HUD does not explicitly indicate that an item, resource, container, tool,
or block is present and reachable, treat it as unavailable.
Do NOT assume the contents of any container unless the HUD explicitly lists those items.
Do NOT include exploratory actions, checks, searches, attempts, or heuristics.
Include a subtask only if the parent action cannot possibly succeed without it.

Each subtask must be one of the following:
- An "action": a directly executable command available to the robot (see command docs below), with explicit parameters when possible.
- A "goal": a concise natural-language description of a necessary subgoal if no single command fits yet.

Output ONLY this disjoint set of universal subtasks as a JSON list; do not explain reasoning or predict future behavior.

Command docs:
$COMMAND_DOCS

Context:
`;

const BASE_CONTEXT_LINES = [
    '- Agent name: $NAME',
    '- Owner name: $OWNER',
    '- Language: $LANGUAGE',
    '- Personality: $PERSONALITY',
    '- Relevant memory: $MEMORY',
    '- HUD snapshot: $HUD'
];

export function buildDecomposerPrompt({
    introLines = [],
    taskExplanation = '',
    additionalContextLines = []
} = {}) {
    const intro = introLines.join('\n').trim();
    const explanation = taskExplanation.trim();

    const contextLines = [
        ...BASE_CONTEXT_LINES,
        ...additionalContextLines
    ];

    const contextSection = contextLines.join('\n');

    return `${intro.length > 0 ? `${intro}\n` : ''}${explanation.length > 0 ? `\n${explanation}\n` : '\n'}${COMMON_INSTRUCTIONS}${contextSection}
`;
}

export function createDecomposerResponseSchema({
    name = 'decomposer_response',
    childrenDescription = 'List of subtasks generated by this decomposer.'
} = {}) {
    return {
        name,
        strict: true,
        schema: {
            type: 'object',
            properties: {
                children: {
                    type: 'array',
                    description: childrenDescription,
                    items: {
                        type: 'object',
                        properties: {
                            type: {
                                type: 'string',
                                enum: ['action', 'goal'],
                                description: 'Whether this child is an executable command or a higher-level goal.'
                            },
                            content: {
                                type: 'string',
                                description: 'If type=action, provide a MinePal command string like !action(param1, param2,...). If type=goal, provide a concise natural-language goal description.'
                            }
                        },
                        required: ['type', 'content'],
                        additionalProperties: false
                    },
                    additionalProperties: false
                }
            },
            required: ['children'],
            additionalProperties: false
        }
    };
}

export class BaseDecomposerPrompter extends BasePrompter {
    constructor(agent, options = {}) {
        super(agent, options);
        if (new.target === BaseDecomposerPrompter) {
            throw new Error('BaseDecomposerPrompter is abstract and cannot be instantiated directly.');
        }
        this._responseSchema = null;
    }

    getDisplayName() {
        return 'Decomposer';
    }

    getIntroLines() {
        return [];
    }

    getTaskExplanation() {
        return '';
    }

    getAdditionalContextLines() {
        return [];
    }

    getSystemPromptTemplate() {
        return buildDecomposerPrompt({
            introLines: this.getIntroLines(),
            taskExplanation: this.getTaskExplanation(),
            additionalContextLines: this.getAdditionalContextLines()
        });
    }

    getSummaryLabel() {
        return 'Task summary';
    }

    getSummaryFallback() {
        return 'No summary provided.';
    }

    getMetadataLabel() {
        return 'Additional context (JSON)';
    }

    getResponseSchemaName() {
        return 'decomposer_response';
    }

    getChildrenDescription() {
        return 'List of subtasks generated by this decomposer.';
    }

    getResponseSchema() {
        if (!this._responseSchema) {
            this._responseSchema = createDecomposerResponseSchema({
                name: this.getResponseSchemaName(),
                childrenDescription: this.getChildrenDescription()
            });
        }
        return this._responseSchema;
    }

    async buildSystemPrompt({ summary = '', metadata = {}, messages = [] } = {}) {
        const basePrompt = this.getSystemPromptTemplate();
        const enrichedPrompt = await this.injectContext(basePrompt, { messages });

        const summaryLabel = this.getSummaryLabel();
        const fallbackSummary = this.getSummaryFallback();
        const normalizedSummary = summary && summary.trim().length > 0
            ? summary.trim()
            : fallbackSummary;

        const formattedMetadata = this._formatMetadata(metadata);
        const metadataLabel = this.getMetadataLabel();
        const metadataSection = formattedMetadata
            ? `\n${metadataLabel}:\n${formattedMetadata}`
            : '';

        return `${enrichedPrompt}\n${summaryLabel}: ${normalizedSummary}${metadataSection}`;
    }

    async decompose({ summary = '', metadata = {}, messages = [] } = {}) {
        const systemPrompt = await this.buildSystemPrompt({ summary, metadata, messages });
        const response = await this.completeChat({
            systemPrompt,
            turns: messages,
            responseSchema: this.getResponseSchema()
        });

        const responseJson = response?.json ?? null;
        const rawReasoning = typeof response?.reasoning_summary === 'string'
            ? response.reasoning_summary.trim()
            : '';
        const reasoningSummary = rawReasoning.length > 0 ? rawReasoning : null;

        return { responseJson, reasoningSummary };
    }

    attachSubtasksToTree(taskTree, parentNode, subtasks = []) {
        if (!taskTree || !parentNode) {
            return [];
        }

        const addedIds = [];
        const safeSubtasks = Array.isArray(subtasks) ? subtasks : [];

        safeSubtasks.forEach((child, index) => {
            if (!child || typeof child !== 'object') return;
            const content = typeof child.content === 'string' ? child.content.trim() : '';
            if (!content) return;

            const childId = this._generateChildNodeId(parentNode.id, index);
            let node = null;

            if (child.type === 'action') {
                node = createActionNode({
                    id: childId,
                    label: content,
                    command: content
                });
            } else if (child.type === 'goal') {
                node = createNLNode({
                    id: childId,
                    label: content,
                    goalText: content
                });
            } else {
                return;
            }

            try {
                taskTree.addNode(node);
                taskTree.attachChild(parentNode.id, node.id);
                addedIds.push(node.id);
            } catch (err) {
                console.warn(`[${this.getDisplayName()}] Failed to attach child node "${node.id}": ${err.message}`);
            }
        });

        return addedIds;
    }

    _generateChildNodeId(parentId, index) {
        const safeParent = typeof parentId === 'string' && parentId.length > 0
            ? parentId
            : 'node';
        return `${safeParent}-child-${index + 1}`;
    }

    _formatMetadata(metadata) {
        if (!metadata || typeof metadata !== 'object' || Object.keys(metadata).length === 0) {
            return null;
        }

        try {
            return JSON.stringify(metadata, null, 2);
        } catch (err) {
            console.warn(`[${this.getDisplayName()}] Unable to stringify metadata:`, err);
            return String(metadata);
        }
    }
}

